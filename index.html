<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Evolving Canvas — Iteration #1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #0a0e1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            touch-action: none;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #info-overlay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.2);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.5px;
            text-align: right;
            pointer-events: none;
            user-select: none;
        }
        
        #info-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 14, 26, 0.95);
            border: 1px solid rgba(100, 200, 255, 0.3);
            padding: 40px;
            max-width: 500px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.8;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #info-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        #info-panel h1 {
            font-size: 20px;
            font-weight: 300;
            margin-bottom: 20px;
            color: rgba(100, 200, 255, 0.9);
            letter-spacing: 1px;
        }
        
        #info-panel .label {
            color: rgba(255, 180, 100, 0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 20px;
            margin-bottom: 5px;
        }
        
        #info-panel .close-hint {
            margin-top: 30px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info-overlay">
        <div>Iteration #1</div>
        <div id="timestamp"></div>
    </div>
    
    <div id="info-panel">
        <h1>The Evolving Canvas</h1>
        
        <div class="label">Iteration</div>
        <div>#1 — First Breath</div>
        
        <div class="label">Grade</div>
        <div>Not yet evaluated</div>
        
        <div class="label">Artist Statement</div>
        <div>The Evolving Canvas is an autonomous generative art piece. Every 7 minutes, an AI studies its own creation, reflects on what it sees, and evolves the work. No human hand guides the brush. The art is in the becoming.</div>
        
        <div class="close-hint">Press 'i' or tap to close</div>
    </div>

    <script>
        // ==================== PERLIN NOISE ====================
        class PerlinNoise {
            constructor(seed = Math.random() * 1000) {
                this.grad3 = [
                    [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
                ];
                this.p = [];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }
                this.perm = [];
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                }
            }
            
            dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }
            
            mix(a, b, t) {
                return (1 - t) * a + t * b;
            }
            
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                const g00 = this.grad3[this.perm[X + this.perm[Y]] % 12];
                const g10 = this.grad3[this.perm[X + 1 + this.perm[Y]] % 12];
                const g01 = this.grad3[this.perm[X + this.perm[Y + 1]] % 12];
                const g11 = this.grad3[this.perm[X + 1 + this.perm[Y + 1]] % 12];
                
                const n00 = this.dot(g00, x, y);
                const n10 = this.dot(g10, x - 1, y);
                const n01 = this.dot(g01, x, y - 1);
                const n11 = this.dot(g11, x - 1, y - 1);
                
                const u = this.fade(x);
                const v = this.fade(y);
                
                const nx0 = this.mix(n00, n10, u);
                const nx1 = this.mix(n01, n11, u);
                
                return this.mix(nx0, nx1, v);
            }
        }

        // ==================== PARTICLE ====================
        class Particle {
            constructor(x, y, maxSpeed) {
                this.pos = { x, y };
                this.vel = { x: 0, y: 0 };
                this.acc = { x: 0, y: 0 };
                this.maxSpeed = maxSpeed * (0.5 + Math.random() * 0.5);
                this.opacity = 0.3 + Math.random() * 0.4;
                this.hue = Math.random() > 0.7 ? 30 : 190; // Cyan or amber
                this.prevPos = { x, y };
            }
            
            follow(flowField, cols, rows, resolution) {
                const x = Math.floor(this.pos.x / resolution);
                const y = Math.floor(this.pos.y / resolution);
                const index = x + y * cols;
                if (index >= 0 && index < flowField.length) {
                    const force = flowField[index];
                    this.acc.x += force.x;
                    this.acc.y += force.y;
                }
            }
            
            attract(mouseX, mouseY, strength) {
                const dx = mouseX - this.pos.x;
                const dy = mouseY - this.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200 && dist > 0) {
                    const force = strength / (dist * dist);
                    this.acc.x += (dx / dist) * force;
                    this.acc.y += (dy / dist) * force;
                }
            }
            
            update() {
                this.vel.x += this.acc.x;
                this.vel.y += this.acc.y;
                
                const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
                if (speed > this.maxSpeed) {
                    this.vel.x = (this.vel.x / speed) * this.maxSpeed;
                    this.vel.y = (this.vel.y / speed) * this.maxSpeed;
                }
                
                this.prevPos.x = this.pos.x;
                this.prevPos.y = this.pos.y;
                
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
                
                this.acc.x = 0;
                this.acc.y = 0;
            }
            
            edges(width, height) {
                if (this.pos.x > width) {
                    this.pos.x = 0;
                    this.prevPos.x = 0;
                }
                if (this.pos.x < 0) {
                    this.pos.x = width;
                    this.prevPos.x = width;
                }
                if (this.pos.y > height) {
                    this.pos.y = 0;
                    this.prevPos.y = 0;
                }
                if (this.pos.y < 0) {
                    this.pos.y = height;
                    this.prevPos.y = height;
                }
            }
            
            draw(ctx) {
                ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${this.opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(this.prevPos.x, this.prevPos.y);
                ctx.lineTo(this.pos.x, this.pos.y);
                ctx.stroke();
            }
        }

        // ==================== SETUP ====================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel');
        
        let width, height;
        let particles = [];
        let flowField = [];
        let cols, rows;
        const resolution = 20;
        const noiseScale = 0.003;
        const particleCount = 800;
        
        const perlin = new PerlinNoise(Date.now());
        
        let mouseX = 0;
        let mouseY = 0;
        let mouseInfluence = false;
        
        let zOffset = 0;
        
        // Timestamp
        const now = new Date();
        document.getElementById('timestamp').textContent = now.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        // ==================== RESIZE ====================
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            cols = Math.ceil(width / resolution) + 1;
            rows = Math.ceil(height / resolution) + 1;
            
            // Regenerate flow field
            flowField = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const angle = perlin.noise(x * noiseScale, y * noiseScale) * Math.PI * 4;
                    const v = {
                        x: Math.cos(angle) * 0.1,
                        y: Math.sin(angle) * 0.1
                    };
                    flowField.push(v);
                }
            }
            
            // Respawn particles if needed
            if (particles.length === 0) {
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle(
                        Math.random() * width,
                        Math.random() * height,
                        2
                    ));
                }
            }
        }
        
        // ==================== MOUSE / TOUCH ====================
        let touchCount = 0;
        
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseInfluence = true;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseInfluence = false;
        });
        
        canvas.addEventListener('touchstart', (e) => {
            touchCount = e.touches.length;
            if (touchCount === 3) {
                toggleInfo();
            } else if (touchCount === 1) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                mouseInfluence = true;
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                mouseInfluence = true;
            }
        });
        
        canvas.addEventListener('touchend', () => {
            mouseInfluence = false;
            touchCount = 0;
        });
        
        // ==================== INFO PANEL ====================
        function toggleInfo() {
            infoPanel.classList.toggle('visible');
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' || e.key === 'I') {
                toggleInfo();
            }
        });
        
        infoPanel.addEventListener('click', toggleInfo);
        
        // ==================== ANIMATION LOOP ====================
        function animate() {
            // Fade effect for trails
            ctx.fillStyle = 'rgba(10, 14, 26, 0.08)';
            ctx.fillRect(0, 0, width, height);
            
            // Update flow field slowly over time
            zOffset += 0.0003;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const index = x + y * cols;
                    const angle = perlin.noise(
                        x * noiseScale,
                        y * noiseScale,
                        zOffset
                    ) * Math.PI * 4;
                    flowField[index] = {
                        x: Math.cos(angle) * 0.1,
                        y: Math.sin(angle) * 0.1
                    };
                }
            }
            
            // Update and draw particles
            particles.forEach(p => {
                p.follow(flowField, cols, rows, resolution);
                
                if (mouseInfluence) {
                    p.attract(mouseX, mouseY, 50000);
                }
                
                p.update();
                p.edges(width, height);
                p.draw(ctx);
            });
            
            requestAnimationFrame(animate);
        }
        
        // ==================== START ====================
        resize();
        window.addEventListener('resize', resize);
        animate();
    </script>
</body>
</html>
